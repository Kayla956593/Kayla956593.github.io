<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Saturn Ring Cards — Glow</title>
  <!-- 把原本放在 <head> 的 <a id="linkedin-btn"> 移除 -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">

<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#0a0e12}
  #hud{position:fixed;left:24px;bottom:24px;color:#b7c7ff;font:12px monospace;opacity:.7}
  canvas{display:block}

  /* ── Top Bar ─────────────────────────── */
  .topbar{
    position:fixed; top:16px; right:16px; z-index:9999;
    display:flex; gap:10px; align-items:center;
    font-family: ui-sans-serif, system-ui, "Segoe UI", Roboto, Arial;
  }
  .btn{
    display:inline-flex; align-items:center; gap:8px;
    padding:8px 14px; border-radius:12px;
    backdrop-filter: blur(8px) saturate(160%);
	
    background: rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.18);
    color:#fff; text-decoration:none; letter-spacing:.3px;
    font-weight:600; font-size:12px; line-height:1;
    transition:transform .2s ease, box-shadow .2s ease, background .2s ease;
    will-change: transform;
  }
  .btn:hover{ background:rgba(255,255,255,.16); transform:translateY(-2px);
              box-shadow:0 0 0 1px rgba(255,255,255,.18), 0 6px 18px rgba(0,0,0,.25); }
  .btn:active{ transform:translateY(0); }

  .btn .dot{ width:6px; height:6px; border-radius:50%; background:#8ec5ff; }
  .btn--primary .dot{ background:#4cc9f0; }
  .btn--accent  .dot{ background:#ff6b6b; }
  .btn--ghost   .dot{ background:#a5a5a5; }

  /* ── Projects Modal ───────────────────── */
  .modal{
    position:fixed; inset:0; z-index:9998; display:none;
    place-items:center; background:rgba(0,0,0,.45); backdrop-filter: blur(4px);
  }
  .modal.open{ display:grid; }
  .modal-card{
    width:min(920px, 92vw);
    background:rgba(12,18,24,.85);
    border:1px solid rgba(255,255,255,.14);
    border-radius:16px; padding:18px 18px 6px;
    box-shadow: 0 20px 60px rgba(0,0,0,.45);
    color:#eaf2ff; font-family: ui-sans-serif, system-ui,"Segoe UI",Roboto,Arial;
  }
  .modal-head{
    display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;
  }
  .modal-title{ font-weight:800; letter-spacing:.4px; font-size:14px; opacity:.92; }
  .modal-close{
    border:none; background:rgba(255,255,255,.09); color:#fff; cursor:pointer;
    border-radius:10px; padding:6px 10px; font-weight:700; letter-spacing:.3px;
  }
  .grid{
    display:grid; grid-template-columns: repeat(3, minmax(0,1fr));
    gap:12px; padding-bottom:10px;
  }
  @media (max-width:900px){ .grid{ grid-template-columns:1fr 1fr } }
  @media (max-width:560px){ .grid{ grid-template-columns:1fr } }

  .proj{
    background:rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.10);
    border-radius:14px; padding:12px; display:flex; flex-direction:column; gap:8px;
    transition: transform .2s ease, background .2s ease;
  }
  .proj:hover{ transform: translateY(-2px); background:rgba(255,255,255,.10); }
  .proj h4{ margin:0; font-size:13px; letter-spacing:.2px; }
  .proj p{ margin:0; font-size:12px; opacity:.85; line-height:1.4; }
  .tags{ display:flex; gap:6px; flex-wrap:wrap; margin-top:4px; }
  .tag{
    font-size:11px; padding:3px 8px; border-radius:999px;
    background:rgba(120,180,255,.16); border:1px solid rgba(120,180,255,.25);
  }
  .proj a{
    align-self:flex-start; margin-top:6px;
    text-decoration:none; color:#fff; font-weight:700; font-size:12px;
    background:rgba(255,255,255,.14); border:1px solid rgba(255,255,255,.22);
    padding:6px 10px; border-radius:10px;
  }
  .proj a:hover{ background:rgba(255,255,255,.22); }
  canvas { touch-action: none; }
  .font-family: 'Inter', 'Helvetica Neue', sans-serif;
.font-weight: 500;
.letter-spacing: 0.02em;
</style>

  <!-- import map：讓 'three' 與 addons 在瀏覽器可用 -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="hud">Scroll or swipe to rotate the ring…</div>
  <canvas id="webgl">
  </canvas>

<!-- ── Topbar ── -->
<nav class="topbar" aria-label="Quick actions">
  <a class="btn btn--ghost" id="email-btn" href="#" aria-label="Email Kayla">
    <span class="dot"></span><span>Email</span>
  </a>
  <a class="btn btn--ghost" href="kayla-cv-data.pdf" download aria-label="Download Resume" rel="noopener">
    <span class="dot"></span><span>Resume</span>
  </a>
  <a class="btn btn--ghost" href="https://www.linkedin.com/in/kayla-liao-a9a958277/" target="_blank" rel="noopener">
    <span class="dot"></span><span>LinkedIn</span>
  </a>
  <a class="btn btn--ghost" href="https://github.com/Kayla956593" target="_blank" rel="noopener">
    <span class="dot"></span><span>Github</span>
  </a>
</nav>

<!-- ── Projects Modal ── -->
<div class="modal" id="projects-modal" role="dialog" aria-modal="true" aria-labelledby="projects-title">
  <div class="modal-card">
    <div class="modal-head">
      <div id="projects-title" class="modal-title">Projects</div>
      <button class="modal-close" id="projects-close">Close</button>
    </div>
    <div class="grid">
      <div class="proj">
        <h4>Secure Boot Validator</h4>
        <p>Firmware toolchain that verifies boot chain (UEFI/TPM/ACM). Cut boot issues by 15%.</p>
        <div class="tags"><span class="tag">C/C++</span><span class="tag">UEFI</span><span class="tag">TPM</span></div>
        <a href="#" target="_blank" rel="noopener">Case Study</a>
      </div>
      <div class="proj">
        <h4>Real-time SPDM Monitor</h4>
        <p>Packet inspector + visualizer for device attestation. Live charts & alerts.</p>
        <div class="tags"><span class="tag">Rust</span><span class="tag">SPDM</span><span class="tag">gRPC</span></div>
        <a href="#" target="_blank" rel="noopener">Demo</a>
      </div>
      <div class="proj">
        <h4>WebGL Portfolio (This)</h4>
        <p>Physically-based glass cards, custom shaders, and post-FX. Built from scratch.</p>
        <div class="tags"><span class="tag">WebGL</span><span class="tag">Shaders</span><span class="tag">UX</span></div>
        <a href="#" target="_blank" rel="noopener">Write-up</a>
      </div>
    </div>
  </div>
</div>


  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
	// for Cards
	import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
	import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
	//
	import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

	const GradeShader = {
	  uniforms: {
		tDiffuse: { value: null },
		vignette: { value: 0.35 },   // 0~1 越大越暗角
    lift:{value:0.00},      // ↓ 不抬暗部，避免霧灰
    gain:{value:1.00},      // ↓ 不增高光，避免泛白
    sat:{value:1.08},       // ↑ 稍回飽和
		grainAmp: { value: 0.025 },  // 顆粒強度
		abAmt:{value:0.0},      // 關色差，避免彩邊
		time:     { value: 0 }
	  },
	  vertexShader: /* glsl */`
		varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.); }
	  `,
	  fragmentShader: /* glsl */`
		uniform sampler2D tDiffuse; uniform float vignette,lift,gain,sat,grainAmp,abAmt,time;
		varying vec2 vUv;
		float hash(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7))+time*12.9898)*43758.5453); }
		vec3 grade(vec3 c){
		  c = mix(vec3(0.), c, 1.0-lift) * gain;               // lift / gain
		  float l = dot(c, vec3(0.2126,0.7152,0.0722));         // luminance
		  c = mix(vec3(l), c, sat);                             // saturation 
		  float v = smoothstep(1.25, 0.05, length(vUv-0.5)) * vignette;

		  return c*(1.0-v);
		}
		void main(){
		  // 微色差：對 RGB 取樣位移不同
		  vec2 off = abAmt * (vUv-0.5);
		  vec3 col;
		  col.r = texture2D(tDiffuse, vUv + off).r;
		  col.g = texture2D(tDiffuse, vUv).g;
		  col.b = texture2D(tDiffuse, vUv - off).b;

		  // 顆粒（動態）
		  float g = (hash(vUv*vec2(640.0,360.0)) - 0.5) * grainAmp;
		  col += g;

		  gl_FragColor = vec4(grade(col), 1.0);
    }
  `
};

    // ---------- renderer / scene / camera ----------
    const canvas = document.getElementById('webgl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(42, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(0, 0, 2.6);
    camera.lookAt(0, 10, 0);
	
	// 物理正確光照 + 環境反射來源
	renderer.physicallyCorrectLights = true; // 保險起見
	const pmrem = new THREE.PMREMGenerator(renderer);
	const envTex = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
	scene.environment = envTex;   // 提供反射/折射環境
	// scene.background = envTex; // 若想把背景也換成 HDR，可解開；你現在用漸層就留著

    // ---------- postprocessing ----------
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));// 原本：0.85, 0.8, 0.22
	const bloom = new UnrealBloomPass(
	  new THREE.Vector2(innerWidth, innerHeight),
	  0.35,   // strength ↓
	  0.9,    // radius ↑ 讓光暈更散
	  1.2     // threshold ↑ 不要早早就爆亮
	);

	
	// ★ 新增顏色分級與微色差
	const gradePass = new ShaderPass(GradeShader);
	composer.addPass(gradePass);
    composer.addPass(bloom);

    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
      bloom.setSize(innerWidth, innerHeight);
    });

    // ---------- lights ----------
    // 曝光再低一點（整體不會爆）
	renderer.toneMappingExposure = 0.6; // 原本 1.1

	// 光線：用更柔的組合
	// 1) 一點環境光就好
	const ambient = new THREE.AmbientLight(0xffffff, 0.4); // 原 0.9 → 0.22
	scene.add(ambient);

	// 2) 主光較弱、偏高偏右
	const dir = new THREE.DirectionalLight(0xffffff, 1);  // 原 2.0 → 0.9
	dir.position.set(3, 6, 6);
	scene.add(dir);

	// 3) 補光更弱，只提細節
	const fill = new THREE.DirectionalLight(0xffffff, 0.5); // 原 0.6 → 0.35
	fill.position.set(-6, -2, -4);
	scene.add(fill);

	// （可選）加一盞半球光讓陰影更柔和
	const hemi = new THREE.HemisphereLight(0x9ecaff, 0x0a0e12, 0.6);
	scene.add(hemi);

    // ---------- center "spine" ----------
	const spine = makeDNA({
	  height: 20,   // 依你的畫面微調
	  turns: 7,
	  radius: 0.5
	});
	scene.add(spine);
	
    // particles
    const pGeo = new THREE.BufferGeometry();
    const COUNT = 400, positions = new Float32Array(COUNT*3);
    for (let i=0;i<COUNT;i++){
      const r = 6 + (Math.random()-0.5)*3;
      const a = Math.random()*Math.PI*2;
      const y = (Math.random()-0.5)*7;
      positions[i*3+0] = Math.cos(a)*r;
      positions[i*3+1] = y;
      positions[i*3+2] = Math.sin(a)*r;
    }
    pGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const pMat = new THREE.PointsMaterial({ size:0.035, transparent:true, opacity:.6, color:0xa6e1ff });
    const pts = new THREE.Points(pGeo, pMat); scene.add(pts);
	 
 

//scene.add(watercolors);
	// === DNA 產生器（雙股螺旋 + 珠珠 + 橫桿，皆用 InstancedMesh）===
	function makeDNA({
	  height = 5.6,
	  turns  = 4,
	  radius = 0.4,
	  beadR  = 0.14,
	  rungStep = 0.36,
	  backboneR = 0.035
	} = {}) {
	  const g = new THREE.Group();

	  class HelixCurve extends THREE.Curve {
		constructor(phase=0){ super(); this.phase=phase; }
		getPoint(t){
		  const theta = t * turns * Math.PI * 2 + this.phase;
		  const y = (t - 0.5) * height;
		  return new THREE.Vector3(Math.cos(theta)*radius, y, Math.sin(theta)*radius);
		}
	  }
	  const segs = 400;
	  const curveA = new HelixCurve(0);
	  const curveB = new HelixCurve(Math.PI);

	  // 主幹
	  const backboneMat = new THREE.MeshPhysicalMaterial({
		color: 0x8ea4b5, metalness: 0.2, roughness: 0.45,
		clearcoat: 0.6, clearcoatRoughness: 0.25, envMapIntensity: 0.7
	  });
	  g.add(new THREE.Mesh(new THREE.TubeGeometry(curveA, segs, backboneR, 14, false), backboneMat));
	  g.add(new THREE.Mesh(new THREE.TubeGeometry(curveB, segs, backboneR, 14, false), backboneMat.clone()));

	  // === 讓「珠珠」與「橫槓」用同一個取樣 ===
	  const rungCount = Math.floor(height / rungStep) + 1;
	  const tAt = (i) => (i / (rungCount - 1));   // 0..1

	  // 珠珠（與橫槓同數量、同 t）
	  const beadGeo = new THREE.SphereGeometry(beadR, 24, 16);
	  const redMat  = new THREE.MeshPhysicalMaterial({ color: 0xd94a4a, metalness:0.15, roughness:0.35, clearcoat:0.7, clearcoatRoughness:0.25, envMapIntensity:0.6 });
	  const blueMat = new THREE.MeshPhysicalMaterial({ color: 0x3aa0ff, metalness:0.15, roughness:0.35, clearcoat:0.7, clearcoatRoughness:0.25, envMapIntensity:0.6 });
	  const beadsA = new THREE.InstancedMesh(beadGeo, redMat,  rungCount);
	  const beadsB = new THREE.InstancedMesh(beadGeo, blueMat, rungCount);

	  const dummy = new THREE.Object3D();
	  for (let i=0;i<rungCount;i++){
		const t = tAt(i);
		dummy.position.copy(curveA.getPoint(t)); dummy.updateMatrix(); beadsA.setMatrixAt(i, dummy.matrix);
		dummy.position.copy(curveB.getPoint(t)); dummy.updateMatrix(); beadsB.setMatrixAt(i, dummy.matrix);
	  }
	  beadsA.instanceMatrix.needsUpdate = true;
	  beadsB.instanceMatrix.needsUpdate = true;
	  g.add(beadsA, beadsB);

	  // 橫槓（A→B，長度扣掉兩顆珠珠半徑）
	  const rungGeo = new THREE.CylinderGeometry(0.02, 0.02, 1, 12); // 半徑可再調
	  const rungMat = new THREE.MeshPhysicalMaterial({ color: 0xcfe6ff, metalness:0.1, roughness:0.5, envMapIntensity:0.5 });
	  const rungs = new THREE.InstancedMesh(rungGeo, rungMat, rungCount);

	  const up = new THREE.Vector3(0,1,0);
	  const a = new THREE.Vector3(), b = new THREE.Vector3(), mid = new THREE.Vector3();
	  for (let i=0;i<rungCount;i++){
		const t = tAt(i);
		a.copy(curveA.getPoint(t));
		b.copy(curveB.getPoint(t));
		mid.addVectors(a,b).multiplyScalar(0.5);

		const dir = b.clone().sub(a);
		const len = Math.max(dir.length() - beadR*2, 0.001);
		dir.normalize();

		dummy.position.copy(mid);
		dummy.quaternion.setFromUnitVectors(up, dir); // Y 軸對齊 A→B
		dummy.scale.set(1, len, 1);                   // 把圓柱拉成正確長度
		dummy.updateMatrix();
		rungs.setMatrixAt(i, dummy.matrix);
	  }
	  rungs.instanceMatrix.needsUpdate = true;
	  g.add(rungs);

	  // 讓外面知道 DNA 的高度，供水彩點 y 分布使用
	  g.userData.height = height;
	  return g;
	}

 const BIOS = [
  // 5 — Craft of the site
  "This site was crafted in WebGL —\nI designed the visuals,\nwrote the shaders,\nand shipped the details.",
  // 1 — Hero
  "Hi, I’m Kayla.\nSoftware & Security Engineer.\nSecure at the core,\nSeamless by design.",

  // 3 — CTA
  "If this work resonates,\nlet’s explore.\nI'd love to see\nwhat we can create together.",

  // 4 — Focus
  "Security. Backend. Interaction.\nFrom protecting data—\nto shaping ideas,\nIf you can imagine it, I can make it."
  
];

function makeLabelTexture(text, opts = {}) {
  const {
    width = 1536,            // 提高解析度更銳利
    padding = 96,
    family  = 'Inter, "Helvetica Neue", Arial, sans-serif',
    baseSize = 52,           // 其餘行
    firstSize = 52,          // 首行放大 ~108%
    firstWeight = 500,
    restWeight  = 500,
    lineHeight = 1.34,       // ★ 關鍵：Apple 感
    tracking = 0.0042,        // 0.004–0.006 之間
    color = '#F7FAFF',       // 比 #EAF2FF 再亮一點
    align = 'left',
	shadow= 'rgba(0,0,0,0)' // 或極淡 0.12 + blur 3
  } = opts;

  const dpr = Math.min(window.devicePixelRatio || 1, 2.5);
  const c = document.createElement('canvas');
  const ctx = c.getContext('2d');
  c.width = Math.floor(width * dpr);

  const setFont = (w, size) => { ctx.font = `${w} ${size * dpr}px ${family}`; };

  // 先用 base 字體做換行量測
  setFont(restWeight, baseSize);
  ctx.textBaseline = 'top';
  ctx.fillStyle = color;

  const maxW = c.width - Math.floor(padding * 2 * dpr);
  const rawLines = text.split('\n');

  // 逐行 wrap（保留原分段）
  const lines = [];
  rawLines.forEach((para, idx) => {
    const words = [...para]; // 逐字，兼容中英
    let line = '';
    const isFirst = (idx === 0);
    setFont(isFirst ? firstWeight : restWeight, isFirst ? firstSize : baseSize);
    for (const ch of words) {
      const test = line + ch;
      if (ctx.measureText(test).width > maxW && line) { lines.push({str: line, isFirst}); line = ch; }
      else line = test;
    }
    if (line) lines.push({str: line, isFirst});
  });
// 測寬：含 tracking
function measureWithTracking(ctx, str, trackingPx){
  let w = 0;
  for (const ch of str){
    w += ctx.measureText(ch).width;
    if (ch !== ' ') w += trackingPx;
  }
  return w;
}

// 產生行（英文單字換行；CJK 逐字）
function wrapLines(ctx, text, maxW, trackingPx){
  const lines = [];
  for (const para of text.split('\n')){
    const isLatin = /^[\x00-\x7F\s]+$/.test(para); // 粗略判斷英文
    const tokens = isLatin ? para.split(/(\s+)/).filter(t=>t.length) : [...para];
    let line = '';
    for (const tk of tokens){
      const test = line + tk;
      if (measureWithTracking(ctx, test, trackingPx) > maxW && line.trim()){
        lines.push(line.trimEnd());
        line = tk.trimStart();
      } else {
        line = test;
      }
    }
    if (line) lines.push(line.trimEnd());
  }
  return lines;
}

  // 計高
  const lhFirst = firstSize * lineHeight * dpr;
  const lhRest  = baseSize  * lineHeight * dpr;
  const totalH = lines.reduce((h, L) => h + (L.isFirst ? lhFirst : lhRest), padding*dpr*2);
  c.height = Math.ceil(totalH);

  // 重設字體與樣式（無陰影）
  ctx.textBaseline = 'top';
  ctx.fillStyle = color;

  // 繪字（含 tracking）
  function drawWithTracking(str, x, y, w, size){
    setFont(w, size);
    let cx = x, add = tracking * size * dpr;
    for (const ch of str) {
      ctx.fillText(ch, cx, y);
      cx += ctx.measureText(ch).width + add;
    }
  }

  const xBase =
    align === 'center' ? c.width/2 :
    align === 'right'  ? c.width - padding*dpr :
                         padding*dpr;

  let y = padding * dpr;
  for (const L of lines) {
    const size = L.isFirst ? firstSize : baseSize;
    const weight = L.isFirst ? firstWeight : restWeight;
    setFont(weight, size);
    const w = ctx.measureText(L.str).width + (L.str.length-1) * tracking * size * dpr;

    let x = xBase;
    if (align !== 'left') x = align === 'center' ? xBase - w/2 : xBase - w;

    drawWithTracking(L.str, x, y, weight, size);
    y += (L.isFirst ? lhFirst : lhRest);
  }

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.anisotropy = 8;
  tex.needsUpdate = true;
  return tex;
}


 // ---------- cards ring (Saturn style) ----------
    const ring = new THREE.Group(); scene.add(ring);
    const CARD_W = 1, CARD_H = 0.5;
    const RADIUS = 1.1;         // 環靠近脊椎
    const N = 4;
    const cards = [];

	function makeCard(labelText = "") {
	const g = new THREE.Group();

  // 1) 正面玻璃：只有 FrontSide
const glassFront = new THREE.MeshPhysicalMaterial({
  color: 0xcfe6ff,
  transmission: 1.0,
  transparent: true,
  thickness: 0.05,      // 0.06 → 0.05 稍薄，顏色不會過厚
  ior: 1.52,
  roughness: 0.65,      // 0.55 → 0.65 更柔
  metalness: 0.0,
  clearcoat: 0.2,       // 0.0 → 0.2 一點鍍膜柔亮
  clearcoatRoughness: 0.35,
  specularIntensity: 0.1, // 0.0 → 0.1 微鏡面，不刺
  envMapIntensity: 0.0,
  attenuationColor: new THREE.Color(0xaed8ff),
  attenuationDistance: 3.2, // 2.5 → 3.2 邊緣不會太黑
  side: THREE.FrontSide
});

  // 2) 背面磨砂板：Basic + 半透明，完全不受燈光/曝光
  const backMat = new THREE.MeshBasicMaterial({
    color: 0x162029,          // 偏暗藍灰
    transparent: true,
    opacity: 0.28,
    side: THREE.BackSide,
    depthWrite: false,        // 避免把文字/邊線蓋掉
    toneMapped: false
  });

  const bodyFront = new THREE.Mesh(
    new RoundedBoxGeometry(CARD_W, CARD_H, 0.08, 6, Math.min(CARD_W,CARD_H)*0.08),
    glassFront
  );
  const bodyBack = new THREE.Mesh(bodyFront.geometry, backMat.clone());
bodyBack.visible = false;      
  g.add(bodyFront);
  g.add(bodyBack);

  // 3) Fresnel 邊線：改為普通混合、只畫正面，並限制強度
  const rimMat = new THREE.ShaderMaterial({
    uniforms: {
      color:{value:new THREE.Color(0xbfe4ff)},
      intensity:{value:0.22},      // 降低
      power:{value:1.4},
      maxAlpha:{value:0.35},     // 上限，避免變白
	  vignette: { value: 0.28 }, // 0.35 → 0.28
grainAmp: { value: 0.015 }, // 0.025 → 0.015
    },
    vertexShader: `
      varying vec3 vN; varying vec3 vV;
      void main(){
        vec4 mv = modelViewMatrix * vec4(position,1.0);
        vN = normalize(normalMatrix * normal);
        vV = normalize(-mv.xyz);
        gl_Position = projectionMatrix * mv;
      }
    `,
    fragmentShader: `
      uniform vec3 color; uniform float intensity; uniform float power; uniform float maxAlpha;
      varying vec3 vN; varying vec3 vV;
      void main(){
        float f = pow(1.0 - max(dot(normalize(vN), normalize(vV)), 0.0), power);
        float a = min(f * intensity, maxAlpha);
        // 僅正面：gl_FrontFacing 為 false 時讓 alpha = 0
        a *= float(gl_FrontFacing);
        gl_FragColor = vec4(color, a);
      }
    `,
    transparent:true,
    depthWrite:false,
    blending: THREE.NormalBlending, // ← 不再加色
    side: THREE.FrontSide
  });
  const rim = new THREE.Mesh(
    new RoundedBoxGeometry(CARD_W*1.002, CARD_H*1.002, 0.0805, 6, Math.min(CARD_W,CARD_H)*0.08),
    rimMat
  );
  g.add(rim);
  

	  // ★ 文字貼片（透明、避免 Bloom）
	  const labelTex = makeLabelTexture(labelText, {
		width: 1024,
		padding: 56,
		font: '600 48px "Noto Sans TC", system-ui, -apple-system, Segoe UI, Roboto, "PingFang TC", "Microsoft JhengHei", Helvetica, Arial',
		lineHeight: 1.26,
		color: '#EAF2FF',
		align: 'left'
	  });
	  
	  const labelMat = new THREE.MeshBasicMaterial({
		map: labelTex,
		transparent: true,
		opacity: 0.85,
		side: THREE.DoubleSide,
		toneMapped: false   // ★ 不進 tone mapping/Bloom，避免像電視
	  });
	  const label = new THREE.Mesh(
		new THREE.PlaneGeometry(CARD_W - 0.28, CARD_H - 0.28),
		labelMat
	  );       // 貼在玻璃內側
	  g.add(label);

	  // 之後在 tick() 可用來淡入淡出
	  g.userData.labelMat = labelMat;
	  label.position.z = -0.06;         
	  label.rotation.y = Math.PI;  // 讓字不要鏡像（必要時）
	  label.material.depthWrite = false;
	  label.material.polygonOffset = true;
	  label.material.polygonOffsetFactor = -2;
	  label.material.polygonOffsetUnits  = -2; 
// 標籤：避免擋到玻璃的背景抓取
//label.material.depthTest = false; 
label.renderOrder = 999;       // 讓它最後疊上來

	  return g;
	}
    //for (let i=0;i<N;i++){ const c = makeCard(); ring.add(c); cards.push(c); }
	for (let i=0;i<N;i++){
	  const text = BIOS[i % BIOS.length];
	  const c = makeCard(text);
	  ring.add(c); cards.push(c);
	}
	// 想一開始出現在正前方的卡片索引（0..N-1）
	const START_INDEX = 1;

	// 「正前方」的參考角（你的程式裡用的是 3π/2）
	const FRONT_ANGLE = Math.PI / 2; // 如果出現到背後，改成 Math.PI / 2

	// 計算開場角度：讓 START_INDEX 那張卡片落在 FRONT_ANGLE
	const initAngle = FRONT_ANGLE - (START_INDEX * Math.PI * 2) / N;

	// 直接把目前角與目標角都設成它 → 第一幀就正前方
	let ringAngle = initAngle;
	let targetAngle = initAngle;

    // ---------- input（平順旋轉） ----------
    //let ringAngle = 0, targetAngle = 0;
	//targetAngle += 0.0008;   // 速度很慢，幾乎察覺不到；互動時 idle 會歸零照舊
	let twist = 0;          // 目前自轉角
	let twistTarget = 0;    // 目標自轉角（由滾輪/觸控推）
	
	addEventListener('wheel', e => {
	  targetAngle += e.deltaY * 0.0012;   // 你原本轉環的
	  twistTarget += e.deltaY * 0.0030;   // ★ 卡片自轉（調這個速度）
	}, { passive:true });

// === Pointer（滑鼠/觸控通吃）===
let dragging = false;
let lastX = 0, lastY = 0;
let vx = 0, vy = 0;          // 慣性速度（左右控制環、上下控制卡片）
const FRICTION = 0.92;       // 慣性摩擦
const ROTATE_K = 0.0045;     // 左右靈敏度（環）
const TWIST_K  = 0.010;      // 上下靈敏度（卡片）

const canvasEl = document.getElementById('webgl');

canvasEl.addEventListener('pointerdown', (e)=>{
  dragging = true;
  lastX = e.clientX; lastY = e.clientY;
  canvasEl.setPointerCapture(e.pointerId);
});

canvasEl.addEventListener('pointermove', (e)=>{
  if (!dragging) return;
  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;
  lastX = e.clientX; lastY = e.clientY;

  // 立即反應
  targetAngle += dx * ROTATE_K;   // ← 左右滑，轉環
  twistTarget += dy * TWIST_K;    // ← 上下滑，卡片自轉

  // 更新慣性
  vx = dx * ROTATE_K;
  vy = dy * TWIST_K;
});

function endDrag(e){
  if (!dragging) return;
  dragging = false;
  canvasEl.releasePointerCapture?.(e.pointerId);
}
canvasEl.addEventListener('pointerup', endDrag);
canvasEl.addEventListener('pointercancel', endDrag);

    let touchX = null;
    // 觸控直向也讓卡片自轉（可選）
	let touchY = null;
	addEventListener('touchstart', e=> { touchY = e.touches[0].clientY; }, { passive:true });
	addEventListener('touchmove',  e=> {
	  if (touchY==null) return;
	  const dy = e.touches[0].clientY - touchY;
	  twistTarget += dy * 0.01;           // ★ 上下滑，卡片繞 Y 轉
	  touchY = e.touches[0].clientY;
	}, { passive:true });
	
	addEventListener('touchend', ()=> touchY=null);
	let aimX = 0, aimY = 0, camX = 0, camY = 0;
	addEventListener('mousemove', e=>{
	  aimX = (e.clientX / innerWidth  - 0.5) * 0.9;  // 可調
	  aimY = (e.clientY / innerHeight - 0.5) * 0.6;
	}, {passive:true});

	// 放在 tick() 外面全域可重複使用
	const qFaceCam = new THREE.Quaternion();
	const qOutward = new THREE.Quaternion();
	const qFinal = new THREE.Quaternion();
	const tmpM = new THREE.Matrix4();
	const up = new THREE.Vector3(0,1,0);

    // ---------- loop ----------
    const invParentQ = new THREE.Quaternion();
    const faceCamQ = new THREE.Quaternion();
	twist += (twistTarget - twist) * 0.1;   // 慣性更順
	
	const Y_AXIS = new THREE.Vector3(0, 1, 0);
	const tmpQ   = new THREE.Quaternion();
	
	let spineAngle = 0;      // 脊椎目前角度
	const SPINE_K = -1.0;     // 轉動比例（1=跟環一樣快；-1=反向）
	const SPINE_PHASE = 0.0; // 相位偏移（想晚半拍可設 Math.PI*0.25）
let frame = 0;
    function tick(){
	if (!dragging) targetAngle += 0.00005; // 很慢、幾乎不打擾操作
 
		gradePass.uniforms.time.value = performance.now() * 0.008;
  // 慣性：放在更新 ringAngle / twist 之前
  if (!dragging) {
    vx *= FRICTION;
    vy *= FRICTION;
    if (Math.abs(vx) > 1e-4) targetAngle += vx;
    if (Math.abs(vy) > 1e-4) twistTarget += vy;
  }

		// 環旋轉
		ringAngle += (targetAngle - ringAngle) * 0.08;
		// 可選：自動慢慢轉（放這裡每幀都會加）

		// 卡片自轉的慣性要在這裡
		twist += (twistTarget - twist) * 0.10;
		// 讓脊椎用慣性追 ringAngle（更順）
		spineAngle += (ringAngle - spineAngle) * 0.12;

		// 只繞 Y 轉；想微微抬頭可加一點 X 傾斜
		spine.rotation.set(0.05, spineAngle * SPINE_K + SPINE_PHASE, 0);

		pts.rotation.y = ringAngle * Math.PI;

		// 只算一次「面向相機」的基準四元數（抵銷父層）
		// 先算好面向相機（抵銷父層）的基準四元數
		// 放在 for 迴圈外：一次算好抵銷父層後的「面向相機」四元數
		const invParentQ = ring.getWorldQuaternion(new THREE.Quaternion()).invert();
		const qFaceCam   = camera.quaternion.clone().premultiply(invParentQ);

		// 參數：最大轉角與曲線形狀
		const MAX_YAW = Math.PI / 4; // 45°
		// 參數
		const MAX_BACK = Math.PI;   // 180°
		const BETA     = 1.0;       // 1.6~2.4：越大在前方越「慢慢地」增加

		for (let i = 0; i < N; i++) {
		  const angle = ringAngle + (i * Math.PI * 2) / N;
		  const x = Math.cos(angle) * RADIUS;
		  const z = Math.sin(angle) * RADIUS;
		  const y = 0;                       // ★ 固定高度
		  const card = cards[i];

		  card.position.set(x, y, z);

		  // 與「正前方」(3π/2) 的最短角差 φ ∈ [-π, π]
		  const FRONT = 1.5 * Math.PI; // 3π/2 = 正前
		  let phi = THREE.MathUtils.euclideanModulo(angle - FRONT + Math.PI, Math.PI * 2) - Math.PI;

		  // ★ 平滑 yaw：0→側面到 45°→背面到 180°
		  const u = Math.abs(phi) / Math.PI;         // 0..1
		  const yawMag = MAX_BACK * Math.pow(u, BETA);  // 大小
		  const yawRad = -Math.sign(phi) * yawMag;      // 方向：右前負、左前正

		  // 先朝向相機，再加繞自身 Y 軸的 yaw
		  card.quaternion.copy(qFaceCam);
		  card.quaternion.multiply(
			new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), yawRad)
		  );

		  // 你的大小/亮度邏輯（可留）
		  const facing = (z / RADIUS + 1) * 0.5;
		  const s = 0.85 + facing * 0.22;
		  card.scale.set(s, s, s); 
		}

	  camX += (aimX - camX) * 0.06;
	  camY += (aimY - camY) * 0.06;
	  camera.position.x = camX;
	  camera.position.y = -camY;
	  camera.lookAt(0,0,0);

      composer.render();
      requestAnimationFrame(tick);
    }
    tick();
	
	// ── Projects Modal 控制 ──
const projectsBtn   = document.getElementById('projects-btn');
const projectsModal = document.getElementById('projects-modal');
const projectsClose = document.getElementById('projects-close');

function openProjects(){ projectsModal.classList.add('open'); }
function closeProjects(){ projectsModal.classList.remove('open'); }

projectsBtn?.addEventListener('click', (e)=>{ e.preventDefault(); openProjects(); });
projectsClose?.addEventListener('click', closeProjects);
projectsModal?.addEventListener('click', (e)=>{ if(e.target === projectsModal) closeProjects(); });

// 快捷鍵：P=Projects, R=Resume, M=Mail
addEventListener('keydown', (e)=>{
  if (e.key.toLowerCase()==='p') openProjects();
  if (e.key.toLowerCase()==='r') location.href='kayla-cv-data.pdf';
 // if (e.key.toLowerCase()==='m') 
  //   window.open('https://mail.google.com/mail/?view=cm&fs=1&to=kayla82456385311@gmail.com', '_blank');
}); 

 // --- Email 按鈕行為（Gmail 優先，mailto 後備） ---
  const email = 'kayla82456385311' + '@' + 'gmail.com';
  const emailBtn = document.getElementById('email-btn');
  // 後備：沒有 Gmail 時至少能叫出系統郵件
  emailBtn.setAttribute('href', 'mailto:' + email);
  emailBtn.addEventListener('click', (e) => {
    e.preventDefault();
    const url = `https://mail.google.com/mail/?view=cm&fs=1&to=${encodeURIComponent(email)}`;
    // 嘗試開 Gmail；被阻擋就退回 mailto
    const win = window.open(url, '_blank', 'noopener');
    if (!win) location.href = 'mailto:' + email;
  });

  // 鍵盤快捷鍵（保持你目前的 M 行為）
  addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'm') {
      const url = `https://mail.google.com/mail/?view=cm&fs=1&to=${encodeURIComponent(email)}`;
      const win = window.open(url, '_blank', 'noopener');
      if (!win) location.href = 'mailto:' + email;
    }
  });
</script>

  </script>
</body>
</html>

